---
title: "In-Lab Class 13"
author: "Jesus (A17597539)"
format: pdf
---
The data for this hands-on session comes from a published RNA-seq experiment where airway smooth muscle cells were treated with **dexamethasone** (dex), a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014).

```{r}
library(DESeq2)
```

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
```

```{r}
head(metadata)
```

>Q1. How many genes are in this dataset? 

There are 38964 genes in this dataset

```{r}
nrow(counts)
```

>Q2. How many ‘control’ cell lines do we have?

We have 4 'control' cell lines

```{r}
table(metadata$dex)
```

```{r}
sum(metadata$dex == "control")
```

## Toy differential gene expression

Let's start by calculating the mean counts per gene in the "control" samples. We can then compare this calue for each gene to the mean counts in the "treated" samples (i.e. columns)

-Step 1.Find which columns in `counts` correspond to the control "samples"

-Step 2. Calculate th mean value per gene in these columns.

-Step3. Store my answer for later as `control.mean`
```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

This is an alternative way to do the same thing using dplyr
```{r}
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

>Q3. How would you make the above code in either approach more robust? Is there a function that could help here? 



>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts[ ,treated$id]
treated.mean <- rowSums( treated.counts )/4 
head(treated.mean)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

>Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(x=meancounts[,1], y=meancounts[,2], xlab="Control", ylab="Treated")
```

>Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

geom_point()

```{r}
library(ggplot2)

ggplot(meancounts) + aes(x=meancounts[,1], y=meancounts[,2]) + geom_point(alpha=0.2) + labs( x="control.mean", y="treated.mean")
```

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

log()

```{r}
ggplot(meancounts) + aes(x=meancounts[,1], y=meancounts[,2]) + geom_point(alpha=0.2) + labs( x="control.mean", y="treated.mean") +scale_x_continuous(trans="log2") +scale_y_continuous(trans="log2")
```

Log transformations are super usesful when our data is skewed and measured over a wide range like this. We can use different log transformations like base10 or natural logs but we most often prefer log2 units

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])

head(meancounts)
```

```{r}
to.rm.inds <- rowSums(meancounts[,1:2]==0) >0
mycounts <- meancounts[!to.rm.inds,]
```

```{r}
dim(mycounts)
```

```{r}
head(mycounts)
```


```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The purpose of the  `arr.ind` fuction in the `which()` function call is to return the positions of a row and column when their values are true

We took the first column of the output and needed to call the `unique()` function because we needed to ensure that we do not count any row twice

Lets add a log2 fold-change column to our little 'meancounts' dataframe

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean/meancounts$control.mean)
```

A common threshold used for calling something differentially expressed is a log2(FoldChange) of greater than 2 or less than -2. Lets filter the dataset both ways to see how many genes are up or down-regulated.
```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind)
```
There are 250 up regulated genes

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind)
```
There are 367 down regulated genes


But we forgot all about statistical significance of these differences...
>Q10. Do you trust these results? Why or why not?

We should not trust these results because we do not know if these results are statistically significant

We will use the DESeq2 package to do this analysis properly...

##Setting up for DESeq

Like any package we must load it up with a `library()` call
```{r}
library(DESeq2)
citation("DESeq2")
```

Setup the input object required by DESeq

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

## Principal Component Analysis (PCA)

```{r}
vsd <- vst(dds, blind = FALSE)
plotPCA(vsd, intgroup = c("dex"))
```

```{r}
pcaData <- plotPCA(vsd, intgroup=c("dex"), returnData=TRUE)
head(pcaData)
```

```{r}
# Calculate percent variance per PC for the plot axis labels
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

```{r}
ggplot(pcaData) +
  aes(x = PC1, y = PC2, color = dex) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

##DESeq Analysis
Now we can run our DESq analysis
```{r}
dds <- DESeq(dds)
```

Get our results back from the `dds` object
```{r}
res <- results(dds)

res
```

```{r}
summary(res)
```

```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```

## A Summary volcano plot

Volcano plot
This is a common type of summary figure that keeps both inner biologists and inner stats nerds happy because it shows both P-values and log2(fold-changes)

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="red", lty=2)
abline(h=-log(0.05), col="blue", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

Save our results to date

```{r}
write.csv(res, file="deseq_results.csv")
```

# Adding Annotation Data

Our result table so far only contains the Ensembl gene IDs. However, alternative gene names and extra annotation are usually required for informative interpretation of our results. In this section we will add this necessary annotation data to our results

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

The main function we will use here is called `mapIds()`

Our current IDS are here:
```{r}
head(row.names(res))

```

These are in ENSEMBLE format. I want "SYMBOL" ids:

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",  #format of our genenames
                     column="SYMBOL", #new format we want to add
                     multiVals="first")

head(res)
```


```{r}
res$genename <-mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",  #format of our genenames
                     column="GENENAME", #new format we want to add
                     multiVals="first")

head(res)
```

```{r}
res$entrez <-mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",  #format of our genenames
                     column="ENTREZID", #new format we want to add
                     multiVals="first")

head(res)
```

## Pathway analysis

We will use the **gage** package along with the **pathview** here to do geneset enrichment (a.k.a pathway analysis) and figure generation respectively.

```{r}
#|message: false
library(pathview)
library(gage)
library(gageData)
```

Let's have a peek at the first two pathways:
```{r}
data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

What we eed for `gage()` is our genes in ENTREZ id format with a measure of their importance.

It wants a vector of e.g. fold-changes

```{r}
foldchanges <-  res$log2FoldChange
```

Add ENTREZ ids as `names()` to my `foldchanges` vector
```{r}
names(foldchanges) = res$entrez

head(foldchanges)
```

Now we can run`gage()` with this input vector and the gene set we want to examine fot the overlap/enrichment...

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

Look at the results
```{r}
attributes(keggres)
```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

We can view these pathways with our gene set genes highlighted using the `pathview()` function. E.g. for "Asthma" I will use the pathway.id hsa05310 as seen above

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

![My genes involved in Asthma pathway](hsa05310.pathview.png)

